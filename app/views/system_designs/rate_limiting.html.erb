<div class="mx-auto max-w-4xl text-center bg-white px-6 py-24 sm:py-32 lg:px-8">
  <p class="text-base font-semibold leading-7 text-gray-600">System Design</p>
  <h1 class="mt-2 text-4xl font-bold tracking-tight text-black sm:text-6xl">Rate Limiting</h1>
  <p class="mt-6 text-lg leading-8 text-gray-600">
    A technique used to control the amount of requests a user can make to an API within a certain timeframe.
  </p>
  
  <div class="mt-10 flex items-center justify-center gap-x-6">
    <%= link_to "â† Back to System Designs", root_path, class: "rounded-md bg-black px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-gray-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-black" %>
  </div>
</div>
<div class="bg-white px-6 py-8 sm:py-12 lg:px-8">
  <div class="mx-auto max-w-4xl text-base leading-7 text-gray-700">
    <div class="mt-10 max-w-3xl">
      <h2 class="mt-8 text-2xl font-bold tracking-tight text-black">Token Bucket Algorithm</h2>
      <p class="mt-4">
        For this implementation, we're using the <strong>Token Bucket</strong> algorithm. Here's how it works:
      </p>
      <ul class="mt-4 list-disc pl-5 space-y-2">
        <li>Each user has a "bucket" that can hold up to a maximum number of tokens (requests)</li>
        <li>Tokens are added to the bucket at a fixed rate over time</li>
        <li>Each API request consumes one token</li>
        <li>When the bucket is empty, further requests are rejected until more tokens become available</li>
        <li>Our implementation: 5 requests per minute, with 1 request refilled per 12 seconds</li>
      </ul>
      
      <div class="mt-10 bg-gray-50 p-6 rounded-lg border border-gray-200">
        <h3 class="text-lg font-bold tracking-tight text-black">Live Demo</h3>
        <p class="mt-2">
          Click the button below to make API requests and observe the rate limiting in action. After 5 requests in a short period, you'll be rate limited.
        </p>
        
        <div class="mt-4">
          <div class="border rounded-md p-4 bg-white">
            <h4 class="text-sm font-medium">API Requests</h4>
            <div id="api-response" class="mt-2 h-32 overflow-y-auto p-2 bg-gray-100 rounded text-sm font-mono">
              <div class="text-gray-500">Response will appear here...</div>
            </div>
            
            <div class="mt-4 flex gap-2">
              <button id="make-request" class="rounded-md bg-black px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-gray-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-black">
                Make API Request
              </button>
              
              <button id="reset-limit" class="rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50">
                Reset Counter
              </button>
            </div>
          </div>
        </div>
        
        <div class="mt-6">
          <h4 class="text-sm font-medium">Current Rate Limit Status</h4>
          <div class="mt-2">
            <div class="text-sm">
              <span>Requests made: </span>
              <span id="request-count"><%= session[:api_attempts]&.size || 0 %></span>
              <span> / 5</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 mt-1">
              <div id="progress-bar" class="bg-black h-2.5 rounded-full" style="width: <%= [(session[:api_attempts]&.size || 0) * 20, 100].min %>%"></div>
            </div>
          </div>
        </div>
      </div>
      
      <h2 class="mt-10 text-2xl font-bold tracking-tight text-black">Implementation in Rails 8</h2>
      
      <div class="mt-4 bg-gray-100 p-4 rounded-md border border-gray-200">
        <pre class="text-sm overflow-x-auto"><code>def apply_rate_limit
  # Implementation of token bucket algorithm
  session[:api_attempts] ||= []
  
  # Configuration 
  max_requests = 5           # Maximum tokens in the bucket
  refill_rate = 1            # Tokens added per second
  window_size = 60           # Window size in seconds
  
  # Clean old requests outside the window
  current_time = Time.now
  session[:api_attempts].reject! { |time| (current_time - time) > window_size }
  
  # Get count of requests within window
  request_count = session[:api_attempts].size
  
  # Calculate allowed requests based on refill rate and time elapsed since first request
  if request_count > 0
    first_request_time = session[:api_attempts].first
    time_elapsed = [current_time - first_request_time, 0].max
    allowed_requests = [max_requests, (time_elapsed * refill_rate).to_i].min
    
    # If more requests than allowed, reject
    if request_count >= max_requests
      rate_limit_header = {
        'X-RateLimit-Limit' => max_requests.to_s,
        'X-RateLimit-Remaining' => '0',
        'X-RateLimit-Reset' => (window_size - (current_time - first_request_time)).to_i.to_s
      }
      
      render json: { 
        error: "Rate limit exceeded. Try again later.",
        retry_after: (window_size - (current_time - first_request_time)).to_i
      }, status: :too_many_requests, headers: rate_limit_header
      return
    end
  end
end</code></pre>
      </div>
      
      <h2 class="mt-10 text-2xl font-bold tracking-tight text-black">Benefits and Considerations</h2>
      <ul class="mt-4 list-disc pl-5 space-y-2">
        <li>Protects your API from abuse and denial-of-service attacks</li>
        <li>Ensures fair usage across all clients</li>
        <li>Helps stabilize your system during traffic spikes</li>
        <li>Consider using Redis for distributed rate limiting in production</li>
        <li>Make sure to include clear rate limit headers for API consumers</li>
      </ul>
    </div>
  </div>
</div>

<script>
document.addEventListener('turbo:load', function() {
  const makeRequestButton = document.getElementById('make-request');
  const resetLimitButton = document.getElementById('reset-limit');
  const apiResponse = document.getElementById('api-response');
  const requestCount = document.getElementById('request-count');
  const progressBar = document.getElementById('progress-bar');
  
  function updateRateLimitUI(count) {
    requestCount.textContent = count;
    progressBar.style.width = `${Math.min(count * 20, 100)}%`;
  }
  
  function appendResponse(message, isError = false) {
    const div = document.createElement('div');
    div.className = isError ? 'text-gray-800' : 'text-gray-800';
    div.textContent = message;
    apiResponse.appendChild(div);
    apiResponse.scrollTop = apiResponse.scrollHeight;
  }
  
  makeRequestButton.addEventListener('click', function() {
    fetch('/system_designs/api_demo', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    })
    .then(response => {
      if (!response.ok) {
        return response.json().then(data => {
          throw new Error(`Rate limit exceeded. Try again in ${data.retry_after} seconds.`);
        });
      }
      return response.json();
    })
    .then(data => {
      updateRateLimitUI(data.request_count);
      appendResponse(`Request #${data.request_count} successful at ${new Date(data.timestamp).toLocaleTimeString()}`);
    })
    .catch(error => {
      appendResponse(error.message, true);
    });
  });
  
  resetLimitButton.addEventListener('click', function() {
    fetch('/system_designs/reset_rate_limit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      }
    })
    .then(() => {
      updateRateLimitUI(0);
      apiResponse.innerHTML = '<div class="text-gray-500">Rate limit reset. You can make requests again.</div>';
    });
  });
});
</script>
